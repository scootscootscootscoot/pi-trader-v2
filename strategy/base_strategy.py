"""
Base strategy system for trading bot.

This module provides the core strategy framework with decision interfaces,
trade signal generation from AI responses, and risk management capabilities.
"""

import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
import re

logger = logging.getLogger(__name__)


@dataclass
class TradeSignal:
    """Represents a trading signal generated by the strategy."""
    symbol: str
    action: str  # 'buy', 'sell', 'hold'
    price: float
    confidence: int  # 0-100
    reason: str
    quantity: Optional[int] = None
    stop_loss: Optional[float] = None


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.

    Defines the core interface for generating trade signals,
    managing risk, and executing trades based on AI predictions.
    """

    def __init__(self, trading_client=None, risk_per_trade: float = 0.02, max_confidence_threshold: int = 80):
        """
        Initialize the base strategy.

        Args:
            trading_client: Trading client for executing orders
            risk_per_trade: Maximum percentage of equity to risk per trade (default 2%)
            max_confidence_threshold: Minimum confidence level to execute trades (0-100)
        """
        self.trading_client = trading_client
        self.risk_per_trade = risk_per_trade
        self.max_confidence_threshold = max_confidence_threshold

    @abstractmethod
    def generate_signals(self, ai_response: str, market_data: Optional[Dict[str, Any]] = None) -> List[TradeSignal]:
        """
        Generate trade signals from AI response.

        Args:
            ai_response: Raw AI prediction/response string
            market_data: Optional current market data for context

        Returns:
            List of TradeSignal objects representing the strategy's decisions
        """
        pass

    @abstractmethod
    def should_execute_signal(self, signal: TradeSignal, account_summary: Dict[str, Any]) -> bool:
        """
        Determine if a signal should be executed based on current account state.

        Args:
            signal: The trade signal to evaluate
            account_summary: Current account information (equity, positions, etc.)

        Returns:
            True if the signal should be executed
        """
        pass

    def parse_ai_response(self, response: str) -> List[TradeSignal]:
        """
        Parse AI response string into TradeSignal objects.

        Assumes AI responses follow the format defined in prompt_builder templates:
        "SYMBOL: [SIGNAL] at $[PRICE] - Confidence: X% - Reason: [explanation]"

        Args:
            response: Raw AI response text

        Returns:
            List of parsed trade signals
        """
        signals = []
        lines = response.strip().split('\n')

        # Regex pattern to match signal format
        pattern = r'SYMBOL:\s*([A-Z]+):\s*\[([^\]]+)\]\s*at\s*\$\s*([0-9.]+)\s*-\s*Confidence:\s*(\d+)%\s*-\s*Reason:\s*(.+)'

        for line in lines:
            line = line.strip()
            if not line:
                continue

            match = re.search(pattern, line, re.IGNORECASE)
            if match:
                symbol, action, price_str, confidence_str, reason = match.groups()
                try:
                    signal = TradeSignal(
                        symbol=symbol.upper(),
                        action=action.lower(),
                        price=float(price_str),
                        confidence=int(confidence_str),
                        reason=reason.strip()
                    )
                    signals.append(signal)
                    logger.debug(f"Parsed signal: {signal}")
                except (ValueError, TypeError) as e:
                    logger.warning(f"Failed to parse signal from line '{line}': {e}")
            else:
                logger.debug(f"No signal pattern match in line: '{line}'")

        return signals

    def calculate_position_size(self, account_equity: float, entry_price: float,
                              stop_loss_price: float, risk_per_trade: Optional[float] = None) -> int:
        """
        Calculate position size based on risk management parameters.

        Uses the formula: Position Size = (Risk Amount) / (Entry Price - Stop Loss Price)
        where Risk Amount = risk_per_trade * account_equity

        Args:
            account_equity: Current account equity
            entry_price: Intended entry price
            stop_loss_price: Stop loss price
            risk_per_trade: Risk percentage (overrides instance default if provided)

        Returns:
            Integer quantity of shares to trade
        """
        risk_pct = risk_per_trade or self.risk_per_trade

        if risk_pct <= 0 or risk_pct > 1:
            logger.warning(f"Invalid risk percentage: {risk_pct}. Using default 2%.")
            risk_pct = 0.02

        if entry_price <= 0 or stop_loss_price <= 0:
            logger.error("Invalid prices for position sizing calculation")
            return 0

        risk_amount = risk_pct * account_equity
        stop_distance = abs(entry_price - stop_loss_price)

        if stop_distance == 0:
            logger.warning("Entry price equals stop loss price, cannot calculate position size")
            return 0

        shares_float = risk_amount / stop_distance
        shares = int(shares_float // 1)  # Round down to whole shares

        logger.debug(f"Calculated position size: {shares} shares "
                    ".3f")

        return shares

    def calculate_stop_loss(self, entry_price: float, risk_type: str = 'percentage',
                          risk_value: float = 0.05, atr: Optional[float] = None) -> float:
        """
        Calculate stop loss price based on risk parameters.

        Args:
            entry_price: Entry price for the position
            risk_type: Type of risk calculation ('percentage', 'atr', 'fixed')
            risk_value: Risk value (percentage as decimal or fixed amount)
            atr: Average True Range for ATR-based stops (optional)

        Returns:
            Stop loss price
        """
        if entry_price <= 0:
            logger.error("Invalid entry price for stop loss calculation")
            return 0.0

        if risk_type == 'percentage':
            # Percentage-based stop loss (e.g., 5% below entry)
            return entry_price * (1 - risk_value)
        elif risk_type == 'atr' and atr is not None:
            # ATR-based stop loss (entry - 2*ATR for long positions)
            return entry_price - (2 * atr)
        elif risk_type == 'fixed':
            # Fixed dollar amount stop loss
            return entry_price - risk_value
        else:
            # Default to 5% stop loss
            logger.warning(f"Unknown risk type '{risk_type}', defaulting to 5% stop loss")
            return entry_price * 0.95

    def get_account_summary(self) -> Dict[str, Any]:
        """
        Get current account summary including equity, positions, and buying power.

        Returns:
            Dictionary containing account information
        """
        if not self.trading_client:
            logger.warning("No trading client available for account summary")
            return {}

        try:
            account = self.trading_client.get_account()
            positions = self.trading_client.get_positions()

            return {
                'equity': account.get('equity', 0),
                'buying_power': account.get('buying_power', 0),
                'cash': account.get('cash', 0),
                'positions': positions,
                'account_status': account.get('status', 'unknown')
            }
        except Exception as e:
            logger.error(f"Failed to get account summary: {e}")
            return {}

    def execute_signal(self, signal: TradeSignal) -> bool:
        """
        Execute a single trade signal through the trading client.

        Args:
            signal: The trade signal to execute

        Returns:
            True if the order was successfully placed
        """
        if not self.trading_client:
            logger.error("No trading client available for executing signals")
            return False

        if not self.should_execute_signal(signal, self.get_account_summary()):
            logger.info(f"Signal not approved for execution: {signal}")
            return False

        try:
            if signal.action == 'buy':
                return self._execute_buy_signal(signal)
            elif signal.action == 'sell':
                return self._execute_sell_signal(signal)
            else:
                logger.info(f"Ignoring hold signal: {signal}")
                return True  # Hold is not an executable action

        except Exception as e:
            logger.error(f"Failed to execute signal {signal}: {e}")
            return False

    def _execute_buy_signal(self, signal: TradeSignal) -> bool:
        """Execute a buy signal."""
        if signal.quantity is None:
            # Calculate position size if not provided
            account = self.get_account_summary()
            equity = account.get('equity', 0)
            stop_loss = signal.stop_loss or self.calculate_stop_loss(signal.price)
            signal.quantity = self.calculate_position_size(equity, signal.price, stop_loss)

        if signal.quantity <= 0:
            logger.warning(f"Invalid quantity calculated for buy signal: {signal}")
            return False

        # Place limit order at signal price
        order_id = self.trading_client.place_limit_order(
            symbol=signal.symbol,
            qty=signal.quantity,
            limit_price=signal.price,
            side='buy'
        )

        # Place corresponding stop loss order if needed
        if signal.stop_loss:
            self.trading_client.place_stop_order(
                symbol=signal.symbol,
                qty=signal.quantity,
                stop_price=signal.stop_loss,
                side='sell'
            )

        logger.info(f"Executed buy signal for {signal.quantity} {signal.symbol} at ${signal.price}")
        return True

    def _execute_sell_signal(self, signal: TradeSignal) -> bool:
        """Execute a sell signal."""
        # For sell signals, we generally sell all positions in the symbol
        account = self.get_account_summary()
        positions = account.get('positions', [])

        # Find current position for this symbol
        position_qty = 0
        for pos in positions:
            if pos['symbol'] == signal.symbol:
                position_qty = abs(pos['qty'])  # Take absolute value
                break

        if position_qty == 0:
            logger.warning(f"No position found for sell signal {signal}")
            return False

        # Place market sell order
        order_id = self.trading_client.place_market_order(
            symbol=signal.symbol,
            qty=position_qty,
            side='sell'
        )

        logger.info(f"Executed sell signal for {position_qty} {signal.symbol}")
        return True

    def execute_signals(self, signals: List[TradeSignal]) -> List[bool]:
        """
        Execute multiple trade signals.

        Args:
            signals: List of signals to execute

        Returns:
            List of boolean results indicating success for each signal
        """
        results = []
        for signal in signals:
            result = self.execute_signal(signal)
            results.append(result)
        return results

    def log_strategy_performance(self, signals: List[TradeSignal], results: List[bool]):
        """
        Log strategy performance metrics.

        Args:
            signals: Signals that were processed
            results: Execution results for each signal
        """
        total_signals = len(signals)
        executed_signals = sum(results)
        success_rate = (executed_signals / total_signals * 100) if total_signals > 0 else 0

        logger.info(f"Strategy execution summary: {executed_signals}/{total_signals} signals executed "
                   ".1f")

        # Log details of failed signals
        for signal, success in zip(signals, results):
            if not success:
                logger.debug(f"Failed to execute: {signal}")


class SimpleAggressiveStrategy(BaseStrategy):
    """
    Simple aggressive strategy implementation.

    Executes signals with high confidence (>80%) and implements
    basic percentage-based stop losses.
    """

    def generate_signals(self, ai_response: str, market_data: Optional[Dict[str, Any]] = None) -> List[TradeSignal]:
        """Generate signals by parsing AI response."""
        return self.parse_ai_response(ai_response)

    def should_execute_signal(self, signal: TradeSignal, account_summary: Dict[str, Any]) -> bool:
        """Execute signals above confidence threshold."""
        return signal.confidence >= self.max_confidence_threshold
